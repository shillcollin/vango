// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: apps.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApp = `-- name: CreateApp :one
INSERT INTO apps (team_id, name, slug, github_repo, github_branch, github_installation_id, region, auto_deploy)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, team_id, name, slug, github_repo, github_branch, github_installation_id, fly_app_id, region, auto_deploy, created_at, updated_at
`

type CreateAppParams struct {
	TeamID               pgtype.UUID `db:"team_id" json:"team_id"`
	Name                 string      `db:"name" json:"name"`
	Slug                 string      `db:"slug" json:"slug"`
	GithubRepo           pgtype.Text `db:"github_repo" json:"github_repo"`
	GithubBranch         pgtype.Text `db:"github_branch" json:"github_branch"`
	GithubInstallationID pgtype.Int8 `db:"github_installation_id" json:"github_installation_id"`
	Region               pgtype.Text `db:"region" json:"region"`
	AutoDeploy           pgtype.Bool `db:"auto_deploy" json:"auto_deploy"`
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) (App, error) {
	row := q.db.QueryRow(ctx, createApp,
		arg.TeamID,
		arg.Name,
		arg.Slug,
		arg.GithubRepo,
		arg.GithubBranch,
		arg.GithubInstallationID,
		arg.Region,
		arg.AutoDeploy,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.Slug,
		&i.GithubRepo,
		&i.GithubBranch,
		&i.GithubInstallationID,
		&i.FlyAppID,
		&i.Region,
		&i.AutoDeploy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEnvVar = `-- name: CreateEnvVar :one

INSERT INTO env_vars (app_id, key, value_encrypted, nonce)
VALUES ($1, $2, $3, $4)
ON CONFLICT (app_id, key) DO UPDATE SET
    value_encrypted = EXCLUDED.value_encrypted,
    nonce = EXCLUDED.nonce,
    updated_at = NOW()
RETURNING id, app_id, key, value_encrypted, nonce, created_at, updated_at
`

type CreateEnvVarParams struct {
	AppID          pgtype.UUID `db:"app_id" json:"app_id"`
	Key            string      `db:"key" json:"key"`
	ValueEncrypted []byte      `db:"value_encrypted" json:"value_encrypted"`
	Nonce          []byte      `db:"nonce" json:"nonce"`
}

// Environment variable queries
func (q *Queries) CreateEnvVar(ctx context.Context, arg CreateEnvVarParams) (EnvVar, error) {
	row := q.db.QueryRow(ctx, createEnvVar,
		arg.AppID,
		arg.Key,
		arg.ValueEncrypted,
		arg.Nonce,
	)
	var i EnvVar
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Key,
		&i.ValueEncrypted,
		&i.Nonce,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllAppEnvVars = `-- name: DeleteAllAppEnvVars :exec
DELETE FROM env_vars WHERE app_id = $1
`

func (q *Queries) DeleteAllAppEnvVars(ctx context.Context, appID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllAppEnvVars, appID)
	return err
}

const deleteApp = `-- name: DeleteApp :exec
DELETE FROM apps WHERE id = $1 AND team_id = $2
`

type DeleteAppParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	TeamID pgtype.UUID `db:"team_id" json:"team_id"`
}

func (q *Queries) DeleteApp(ctx context.Context, arg DeleteAppParams) error {
	_, err := q.db.Exec(ctx, deleteApp, arg.ID, arg.TeamID)
	return err
}

const deleteEnvVar = `-- name: DeleteEnvVar :exec
DELETE FROM env_vars WHERE app_id = $1 AND key = $2
`

type DeleteEnvVarParams struct {
	AppID pgtype.UUID `db:"app_id" json:"app_id"`
	Key   string      `db:"key" json:"key"`
}

func (q *Queries) DeleteEnvVar(ctx context.Context, arg DeleteEnvVarParams) error {
	_, err := q.db.Exec(ctx, deleteEnvVar, arg.AppID, arg.Key)
	return err
}

const getApp = `-- name: GetApp :one
SELECT id, team_id, name, slug, github_repo, github_branch, github_installation_id, fly_app_id, region, auto_deploy, created_at, updated_at FROM apps WHERE id = $1
`

func (q *Queries) GetApp(ctx context.Context, id pgtype.UUID) (App, error) {
	row := q.db.QueryRow(ctx, getApp, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.Slug,
		&i.GithubRepo,
		&i.GithubBranch,
		&i.GithubInstallationID,
		&i.FlyAppID,
		&i.Region,
		&i.AutoDeploy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppBySlug = `-- name: GetAppBySlug :one
SELECT id, team_id, name, slug, github_repo, github_branch, github_installation_id, fly_app_id, region, auto_deploy, created_at, updated_at FROM apps WHERE team_id = $1 AND slug = $2
`

type GetAppBySlugParams struct {
	TeamID pgtype.UUID `db:"team_id" json:"team_id"`
	Slug   string      `db:"slug" json:"slug"`
}

func (q *Queries) GetAppBySlug(ctx context.Context, arg GetAppBySlugParams) (App, error) {
	row := q.db.QueryRow(ctx, getAppBySlug, arg.TeamID, arg.Slug)
	var i App
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.Slug,
		&i.GithubRepo,
		&i.GithubBranch,
		&i.GithubInstallationID,
		&i.FlyAppID,
		&i.Region,
		&i.AutoDeploy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppEnvVars = `-- name: GetAppEnvVars :many
SELECT id, app_id, key, value_encrypted, nonce, created_at, updated_at FROM env_vars WHERE app_id = $1 ORDER BY key
`

func (q *Queries) GetAppEnvVars(ctx context.Context, appID pgtype.UUID) ([]EnvVar, error) {
	rows, err := q.db.Query(ctx, getAppEnvVars, appID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EnvVar{}
	for rows.Next() {
		var i EnvVar
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.Key,
			&i.ValueEncrypted,
			&i.Nonce,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppsByGitHubRepo = `-- name: GetAppsByGitHubRepo :many
SELECT id, team_id, name, slug, github_repo, github_branch, github_installation_id, fly_app_id, region, auto_deploy, created_at, updated_at FROM apps WHERE github_repo = $1
`

func (q *Queries) GetAppsByGitHubRepo(ctx context.Context, githubRepo pgtype.Text) ([]App, error) {
	rows, err := q.db.Query(ctx, getAppsByGitHubRepo, githubRepo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Name,
			&i.Slug,
			&i.GithubRepo,
			&i.GithubBranch,
			&i.GithubInstallationID,
			&i.FlyAppID,
			&i.Region,
			&i.AutoDeploy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnvVar = `-- name: GetEnvVar :one
SELECT id, app_id, key, value_encrypted, nonce, created_at, updated_at FROM env_vars WHERE app_id = $1 AND key = $2
`

type GetEnvVarParams struct {
	AppID pgtype.UUID `db:"app_id" json:"app_id"`
	Key   string      `db:"key" json:"key"`
}

func (q *Queries) GetEnvVar(ctx context.Context, arg GetEnvVarParams) (EnvVar, error) {
	row := q.db.QueryRow(ctx, getEnvVar, arg.AppID, arg.Key)
	var i EnvVar
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Key,
		&i.ValueEncrypted,
		&i.Nonce,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamApps = `-- name: GetTeamApps :many
SELECT id, team_id, name, slug, github_repo, github_branch, github_installation_id, fly_app_id, region, auto_deploy, created_at, updated_at FROM apps WHERE team_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetTeamApps(ctx context.Context, teamID pgtype.UUID) ([]App, error) {
	rows, err := q.db.Query(ctx, getTeamApps, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Name,
			&i.Slug,
			&i.GithubRepo,
			&i.GithubBranch,
			&i.GithubInstallationID,
			&i.FlyAppID,
			&i.Region,
			&i.AutoDeploy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const slugExists = `-- name: SlugExists :one
SELECT EXISTS(SELECT 1 FROM apps WHERE team_id = $1 AND slug = $2)
`

type SlugExistsParams struct {
	TeamID pgtype.UUID `db:"team_id" json:"team_id"`
	Slug   string      `db:"slug" json:"slug"`
}

func (q *Queries) SlugExists(ctx context.Context, arg SlugExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, slugExists, arg.TeamID, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateApp = `-- name: UpdateApp :one
UPDATE apps SET
    name = COALESCE(NULLIF($1::text, ''), name),
    github_branch = COALESCE(NULLIF($2::text, ''), github_branch),
    region = COALESCE(NULLIF($3::text, ''), region),
    auto_deploy = $4,
    updated_at = NOW()
WHERE id = $5 AND team_id = $6
RETURNING id, team_id, name, slug, github_repo, github_branch, github_installation_id, fly_app_id, region, auto_deploy, created_at, updated_at
`

type UpdateAppParams struct {
	Name         string      `db:"name" json:"name"`
	GithubBranch string      `db:"github_branch" json:"github_branch"`
	Region       string      `db:"region" json:"region"`
	AutoDeploy   pgtype.Bool `db:"auto_deploy" json:"auto_deploy"`
	ID           pgtype.UUID `db:"id" json:"id"`
	TeamID       pgtype.UUID `db:"team_id" json:"team_id"`
}

func (q *Queries) UpdateApp(ctx context.Context, arg UpdateAppParams) (App, error) {
	row := q.db.QueryRow(ctx, updateApp,
		arg.Name,
		arg.GithubBranch,
		arg.Region,
		arg.AutoDeploy,
		arg.ID,
		arg.TeamID,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.Slug,
		&i.GithubRepo,
		&i.GithubBranch,
		&i.GithubInstallationID,
		&i.FlyAppID,
		&i.Region,
		&i.AutoDeploy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
