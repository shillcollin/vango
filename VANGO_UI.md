VangoUI: Architectural Specification & Implementation GuideStatus: Finalized Type: Design SpecificationDependency: Vango Core v2.0 (Phase 1-9)1. Executive SummaryVangoUI is a comprehensive component library designed for the Vango framework. It adopts the "Copy-Paste Ownership" distribution model adapted for Go's strongly typed environment.Core Value Proposition:Strict Type Safety: Rejects opts ...any in favor of Typed Functional Options and Enums.Consistent API: Uses a generic BaseConfig pattern so ui.Class, ui.Attr, and ui.Child work across all components.Ownership: Developers own the code via vango add.Separation of Physics: Delegates interaction physics to Standard Client Hooks.2. ArchitectureVangoUI acts as a Façade Layer over Vango Core.| Layer | Responsibility | Example || User Code | Composition | ui.Dialog(ui.Open(sig), ui.Child(...)) || VangoUI | Config & Rendering | Serializes DialogHookConfig -> JSON, renders HTML || Vango Core | Runtime | Manages Signals, WebSocket, DOM Patching || Thin Client | Physics | Runs FocusTrap, Portal hooks |3. The API Design3.1 The Shared Base Pattern (Generics)To avoid repeating option logic for every component, we use a Generic Option Pattern.The Base Config:// app/components/ui/base.go

// BaseConfig is embedded in every component config
type BaseConfig struct {
    Classes []string
    Options []vango.NodeOption // Merged list of Attributes and Children
}

// ConfigProvider interface allows generic options to work on any config
type ConfigProvider interface {
    GetBase() *BaseConfig
}

Generic Options:These options work on any component that embeds BaseConfig and implements GetBase().// app/components/ui/base.go

type Option[T ConfigProvider] func(T)

// Class adds utility classes (merged via CN later)
func Class[T ConfigProvider](c string) Option[T] {
    return func(cfg T) {
        base := cfg.GetBase()
        base.Classes = append(base.Classes, c)
    }
}

// Attr allows passing raw Vango attributes (escape hatch)
func Attr[T ConfigProvider](attr vango.NodeOption) Option[T] {
    return func(cfg T) {
        base := cfg.GetBase()
        base.Options = append(base.Options, attr)
    }
}

// Child allows passing children (strongly typed)
func Child[T ConfigProvider](nodes ...*vango.VNode) Option[T] {
    return func(cfg T) {
        base := cfg.GetBase()
        for _, n := range nodes {
            // Assume vango/el provides a way to treat VNodes as Options, 
            // or wrap them here: el.Child(n)
            base.Options = append(base.Options, el.Child(n))
        }
    }
}

3.2 Component Implementation PatternComponents must use Typed Enums for variants and the Generic Option pattern.Example: Button// 1. Define Typed Enums
type ButtonVariant string
const (
    ButtonVariantDefault ButtonVariant = "default"
    ButtonVariantPrimary ButtonVariant = "primary"
)

type ButtonSize string
const (
    ButtonSizeDefault ButtonSize = "default"
    ButtonSizeLg      ButtonSize = "lg"
)

// 2. Define Component Config
type ButtonConfig struct {
    BaseConfig // Embeds Classes, Options
    Variant    ButtonVariant
    Size       ButtonSize
}

// Implement ConfigProvider interface
func (c *ButtonConfig) GetBase() *BaseConfig { return &c.BaseConfig }

// 3. Define Option Type Alias (for better DX)
type ButtonOption = ui.Option[*ButtonConfig]

// 4. Define Component-Specific Options
func Variant(v ButtonVariant) ButtonOption {
    return func(c *ButtonConfig) { c.Variant = v }
}

// 5. Implementation
func Button(opts ...ButtonOption) *vango.VNode {
    // Default config
    c := &ButtonConfig{
        Variant: ButtonVariantDefault, 
        Size:    ButtonSizeDefault,
    }

    // Apply options
    for _, opt := range opts {
        opt(c)
    }

    // Resolve classes (Base classes + Variant classes + User overrides)
    finalClass := ui.CN(
        buttonVariants(c.Variant, c.Size), 
        strings.Join(c.BaseConfig.Classes, " "),
    )

    // Render
    // Merge calculated class with user-provided options (attrs/children)
    renderOpts := make([]vango.NodeOption, 0, len(c.BaseConfig.Options)+1)
    renderOpts = append(renderOpts, el.Class(finalClass))
    renderOpts = append(renderOpts, c.BaseConfig.Options...)

    return el.Button(renderOpts...)
}

3.3 The CN Utility & ThemingLocation: app/components/ui/utils.goSemantics (v1):CN performs string joining and deduplication.Guarantee: If multiple conflicting classes are present (e.g., p-4 p-2), the order is preserved so that the last class wins based on CSS cascade rules generated by Tailwind.Tokens: VangoUI components define styles using tokens (bg-primary) which map to CSS variables, not hardcoded hex values.// CN merges class lists. Future versions may include conflict resolution (tailwind-merge).
func CN(inputs ...string) string {
    // Implementation: strings.Join + unique filter
}

4. Interactive Components (The Bridge)Interactive components use Typed Hook Configurations and standard event names.4.1 Constants & TypesDo not use magic strings.const (
    HookNameDialog = "Dialog"
    HookEventClose = "close"
)

// 1. The Component Config (Go-side API)
type DialogConfig struct {
    BaseConfig
    Open          *vango.Signal[bool] // Pointer to allow nil check
    OnClose       func()
    CloseOnEscape bool
}

// 2. The Hook Config (Wire Protocol) - JSON tags mandatory
type dialogHookConfig struct {
    Open          bool `json:"open"`
    CloseOnEscape bool `json:"closeOnEscape"`
}

// 3. Mapping Function
func makeDialogHookConfig(c *DialogConfig) dialogHookConfig {
    isOpen := false
    if c.Open != nil {
        isOpen = c.Open.Get()
    }
    return dialogHookConfig{
        Open:          isOpen,
        CloseOnEscape: c.CloseOnEscape,
    }
}

4.2 The Event Wiring PatternInteractive components must standardize event handling logic: Explicit Handler > Signal Toggle.func Dialog(opts ...DialogOption) *vango.VNode {
    // ... apply options ...

    return el.Div(
        // Attach Hook with typed config (core handles struct->JSON)
        el.Hook(HookNameDialog, makeDialogHookConfig(c)),

        // Standard Event Wiring
        el.OnEvent(HookEventClose, func(e vango.HookEvent) {
            if c.OnClose != nil {
                c.OnClose()
            } else if c.Open != nil {
                c.Open.Set(false)
            }
        }),

        // Render content
        el.Div(el.Class("dialog-content"), 
            // Expand BaseConfig.Options (Children/Attrs)
            c.BaseConfig.Options...,
        ),
    )
}

5. Distribution Strategy (CLI)5.1 Version Pinning (vango.json)Projects track their VangoUI version to enable upgrade checks.{
  "ui": {
    "version": "1.0.2",
    "registry": "[https://vango.dev/registry.json](https://vango.dev/registry.json)"
  }
}

5.2 Dependency Resolution & ManifestThe CLI performs topological sort. The manifest explicitly lists dependencies.{
  "components": {
    "button": {
      "files": ["button.go"],
      "dependsOn": ["utils", "base"]
    },
    "base": {
      "files": ["base.go"],
      "dependsOn": []
    }
  }
}

5.3 Source Headers & UpgradesFiles include metadata for 3-way diffs.// Source: vango.dev/ui/button
// Version: 1.0.2
// Checksum: <sha256>

Upgrade Logic:Check: Compare local file checksum vs. header checksum.Match: Safe to overwrite.Mismatch: User has modified code.Action: Prompt user: [Diff] / [Overwrite] / [Skip].6. Implementation RoadmapCore UI: Implement app/components/ui/base.go (Generic Options) and utils.go.Primitives: Build Button using Enums and Generic Options.Interactive: Build Dialog using Typed Hook Config and Event Wiring.CLI: Implement vango add with dependency resolution and topological sort.Codegen: Add vango gen component [Name] to scaffold new components following this strict pattern.